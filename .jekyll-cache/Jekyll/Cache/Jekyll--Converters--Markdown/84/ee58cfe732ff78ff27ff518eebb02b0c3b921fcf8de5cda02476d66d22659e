I"t<h2 id="1插入排序">1.插入排序</h2>

<p>保持L.r[1..i-1]是有序序列，将L.r[i]插入该有序序列中，使得L.r[1..i]成为有序序列；如此进行从i=2到i=n</p>

<h2 id="2快速排序">2.快速排序</h2>

<p>快速排序(Quick Sort)：通过一趟“划分”，将整个序列分为两块，保证后一块的任一关键字都比前一块的任一关键字大<br />
再对两块分别进行进一步“划分”，以递归形式进行，直到不能再细分为止<br />
“划分”思路：从序列中找一个关键字作为枢轴(pivot)，比枢轴大的放在其后面，比枢轴小的放在其前面</p>

<h2 id="3堆排序">3.堆排序</h2>

<p>堆(heap)：堆是一棵完全二叉树，且双亲结点的元素值不大于（不小于）其左右孩子的元素值，根结点的元素值最小（最大）<br />
堆排序(Heap Sort)：假设L.r[1..i]是一个大顶堆，L.r[1]是其中最大的关键字，将其与L.r[i]互换；把L.r[1..i-1]重构造成一个大顶堆；如此进行从i=n到i=2<br /></p>

<h2 id="4归并排序">4.归并排序</h2>

<p>归并排序(Merge Sort)：将L.r[1..n]分为前后两部分L.r[1..n/2]和L.r[n/2+1..n]，对两部分分别进行排序，再把两部分归并起来</p>

<blockquote>
  <p>最后附上GitHub：<a href="https://github.com/zht1999/PCB_flyer">https://github.com/zht1999/PCB_flyer</a></p>
</blockquote>
:ET